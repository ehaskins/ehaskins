{"componentChunkName":"component---src-templates-blog-post-js","path":"/2018-01-30 Z80 DAA/","webpackCompilationHash":"04c9b1c30955a8ce71b4","result":{"data":{"site":{"siteMetadata":{"title":"Eric Haskins","author":"Eric Haskins"}},"markdownRemark":{"id":"f1eda90b-53b7-5a76-8dd0-a54975082655","html":"<h1>Background</h1>\n<p>I’ve been writing a Gameboy emulator. One of the last CPU instructions I have left to implement is <code class=\"language-text\">DAA</code>. I couldn’t find a good explaination of what DAA is, let alone why it’s behavior is what it is.</p>\n<p>I’m writing this post as I try to understand how DAA works and why it exists.</p>\n<h1>Binary Coded Decimal</h1>\n<p>Numbers are normally represented in binary, but sometimes (for reasons I’m not sure about) we encode each decimal digit into binary seperately. We call this seperate encoding of each digit “binary coded decimal”.</p>\n<p>The table below has a few examples. All of the binary and the first 4 BCD values are each 8 bits (1 byte).</p>\n<table>\n<thead>\n<tr>\n<th>Decimal</th>\n<th>Binary</th>\n<th>BCD</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>0000 0001</td>\n<td>0000 (0) 0001 (1)</td>\n</tr>\n<tr>\n<td>10</td>\n<td>0000 1010</td>\n<td>0001 (1) 0000 (0)</td>\n</tr>\n<tr>\n<td>32</td>\n<td>0010 0000</td>\n<td>0011 (3) 0010 (2)</td>\n</tr>\n<tr>\n<td>99</td>\n<td>0110 0011</td>\n<td>1001 (9) 1001 (9)</td>\n</tr>\n<tr>\n<td>100</td>\n<td>0110 0100</td>\n<td>0001 (1) 0000 (0) 0000 (0)</td>\n</tr>\n</tbody>\n</table>\n<p>So, BCD is pretty ineffecient. Wastes 6 of the 16 possible values each 4 bits can hold. I’m not sure why it’s particularly useful. But, apearantly somebody does.</p>\n<h1>BCD Math</h1>\n<p>What happens if we add(or subtract) two BCD values using CPU instuctions designed to be used with regular binary values?</p>\n<h2>Addition</h2>\n<p>Let’s look at a simple case.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1 + 1\n\n(1) 0001\n(1) 0001 +\n------\n(2) 0010</code></pre></div>\n<p>So that worked, let try something a little harder.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">5 + 5\n\n(5)  0101\n(5)  0101 +\n-----------\n(10) 1010</code></pre></div>\n<p>That looks ok, but we’re working in BCD, so the output should be in BCD as well.</p>\n<p>Since 10 is too big to fit in a decimal digit, we need to fix it. It turns out if we add 6 to the result, it produces a valid BCD value.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(10) 1010\n(6)  0110 +\n-----------\n(16) 0001 (1) 0000 (0)</code></pre></div>\n<p>If the sum in greater, than 9, add 6.</p>\n<p>It turns out this works for any single decimal digit addition, even when it overflows into a 5th bit.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(7)       0111\n(9)       1001 +\n----------\n(16) 0001 0000\n\n16 &gt; 9, so\n\n(16) 0001     0000\n(6)  0000     0110 +\n----------------\n     0001 (1) 0110 (6)</code></pre></div>\n<h2>Two Digit Addition</h2>\n<p>Turns out this even works for two digit addition.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">19 + 28 = 47\n\n       11 (carries)\n(19) 0001 (1) 1001 (9)\n(28) 0010 (2) 1000 (8) +\n------------------------\n     0100 (4)   0001 (1)</code></pre></div>\n<p>Looking at the first 4 bits, they’re only 1 which according to our rule wouldn’t need to be corrected, but we need to look at the carry from the 4th to the 5th bit.</p>\n<p>Since there was a carry from the 4th to 5th bit, it the first 4 bit addition really producted <code class=\"language-text\">0001 0001</code>. which is greater than <code class=\"language-text\">9</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">0100 (4)   0001 (1)\n0000 (0)   0110 (6) +\n---------------------\n0100 (4)   0111 (7)</code></pre></div>\n<h2>Subtraction</h2>\n<p>So addition, even with multiple deciaml digits works with the same rule.</p>\n<p>What about subtraction? Well, computers don’t really do subtraction like humans do. They do subtraction by adding the “two’s complement” of the value being subtracted to the value it’s being subtracted from.</p>\n<p>To compute a “two’s complement”, you invert all the bits, then add 1. Odd, I know, but it works.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">47-28=19\n\nComplement of 28\n(28) 0010 (2) 1000 (8)\n     1101     0111 (invert bits)\n                 1 + (add 1)\n    ----------------\n     1101     1000</code></pre></div>\n<p>So now we subtract by adding.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">47-28=19\n\n   1 1\n(48) 0100 (4) 0111 (7)\n     1101     1000\n------------------------\n     0001 (1) 1111 (15)</code></pre></div>\n<p>Our first 4 bits are <code class=\"language-text\">1111 (15)</code>, we know our answer should be <code class=\"language-text\">9</code>. When adding we add 6 to any digit greater than 9. When subtracting, we subtract 6 from any digit greater than 9.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Complement 06\n0000 0110\n1111 1001\nAdd 1\n1111 1010\n\n1\n  0001 (1) 1111 (15)\n  1111     1010 +\n---------------------\n  0001 (1) 1001 (9)</code></pre></div>\n<p>There’s carry out of the 8th bit, but we’ll ignore that.</p>\n<h1>Isn’t This Post About DAA?</h1>\n<p>Now that we know what BCD is, how to correct when it’s added or subtracted in a binary added, we can figure out the logic for DAA.</p>\n<p>DAA is intended to be run immediately after an addition or subtraction operation, where the operands were BCD encoded. It then makes the corrections described above, so the result (stored in the A register) is the BCD encoded result of the previous operation.</p>\n<p>However, DAA doesn’t know what the original values were, and has minimal information about the calculation.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Value to be corrected</td>\n<td>Stored in register A</td>\n</tr>\n<tr>\n<td>Half carry (H) flag</td>\n<td>1 if there was a carry from bit 4 to 5</td>\n</tr>\n<tr>\n<td>Carry (C) flag</td>\n<td>1 if there was a carry from bit 8</td>\n</tr>\n<tr>\n<td>Subtraction (N)</td>\n<td>1 if the previous operation was a subtraction</td>\n</tr>\n</tbody>\n</table>\n<p>We can distill our rules into</p>\n<ul>\n<li>\n<p>If adding</p>\n<ul>\n<li>Add 6 to each digit greater than 9, or if it carried</li>\n</ul>\n</li>\n<li>\n<p>If subtracting</p>\n<ul>\n<li>Subtract 6 from each digit greater than 9, or if it carried</li>\n</ul>\n</li>\n</ul>\n<p>On a Z80, at least, the DAA instruction sets a couple of flags based on the final value. The logic for these is at the end of the function.</p>\n<table>\n<thead>\n<tr>\n<th>Flag</th>\n<th>Condition</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Carry (C)</td>\n<td>Output > 0x99</td>\n</tr>\n<tr>\n<td>Zero (Z)</td>\n<td>Output == 0</td>\n</tr>\n</tbody>\n</table>\n<h1>Some Code…</h1>\n<p>Turns out there’s a lot of poorly documented edge cases in <code class=\"language-text\">daa</code>. This is the code I ended up with, which works.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token constant\">DAA</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">value<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> subtraction<span class=\"token punctuation\">:</span> bool<span class=\"token punctuation\">,</span> carry<span class=\"token punctuation\">:</span> bool<span class=\"token punctuation\">,</span> halfCarry<span class=\"token punctuation\">:</span> bool</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> correction <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">let</span> setFlagC <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>flagH <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>flagN <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">&amp;</span> <span class=\"token number\">0xf</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">9</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    correction <span class=\"token operator\">|=</span> <span class=\"token number\">0x6</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>flagC <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>flagN <span class=\"token operator\">&amp;&amp;</span> value <span class=\"token operator\">></span> <span class=\"token number\">0x99</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    correction <span class=\"token operator\">|=</span> <span class=\"token number\">0x60</span><span class=\"token punctuation\">;</span>\n    setFlagC <span class=\"token operator\">=</span> <span class=\"token constant\">FLAG_C</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  value <span class=\"token operator\">+=</span> flagN <span class=\"token operator\">?</span> <span class=\"token operator\">-</span>correction <span class=\"token punctuation\">:</span> correction<span class=\"token punctuation\">;</span>\n\n  value <span class=\"token operator\">&amp;=</span> <span class=\"token number\">0xff</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> setFlagZ <span class=\"token operator\">=</span> value <span class=\"token operator\">===</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> <span class=\"token constant\">FLAG_Z</span> <span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  regF <span class=\"token operator\">&amp;=</span> <span class=\"token operator\">~</span><span class=\"token punctuation\">(</span><span class=\"token constant\">FLAG_H</span> <span class=\"token operator\">|</span> <span class=\"token constant\">FLAG_Z</span> <span class=\"token operator\">|</span> <span class=\"token constant\">FLAG_C</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  regF <span class=\"token operator\">|=</span> setFlagC <span class=\"token operator\">|</span> setFlagZ<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> output<span class=\"token punctuation\">,</span> carry<span class=\"token punctuation\">,</span> zero <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>So that’s the DAA instruction, though I’m still not sure why you’d want to use BCD.</p>","frontmatter":{"title":"WTF is the DAA instruction?","date":"January 30, 2018"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2018-01-30 Z80 DAA/"}}}